from Crypto.Util.number import getStrongPrime, bytes_to_long, long_to_bytes
from sympy import prevprime, factorial
from math import gcd
import random

# https://stackoverflow.com/questions/9727962/fast-way-to-calculate-n-mod-m-where-m-is-prime

#from secret import FLAG
FLAG="flag"

e = 0x10001

def factorialMod(n, modulus):
	ans=1
	if n <= modulus//2:
		#calculate the factorial normally (right argument of range() is exclusive)
		for i in range(1,n+1):
			 ans = (ans * i) % modulus   
	else:
		#Fancypants method for large n
		for i in range(n+1,modulus):
			ans = (ans * i) % modulus
		ans = pow(ans, -1,modulus)
		ans = -1*ans + modulus
	return ans % modulus
    
    
def getStrongestPrime(p,i):
    while True:
        #p = getStrongPrime(nbits)
        delta = i #random.randint(0x1337, 0x1337 + 0x1337)
        pp = p - delta
        ppp = prevprime(factorialMod(pp,p) % p)
        if gcd(ppp-1, e) == 1:
            return p, ppp

_p0 = 163753477176210014003355280732229891908166074468271556144642666169325605017666799921295576722168608401188682320182653287668989748162506955989407213845500704903463544753049275828138559289189335596749709834289278256382427251831790026921563375111737350084174473833546767952081017613072491759534988253353621530923
_q0 = 157598184809589313845990455272198459548591786211953253450211152128535343234857067521711590445365424087430728267491317690639227988484930088637483194045435135802590588269993794073236513557034321374876808546159597997280236993358749182432517011554239468502233558179815446959403076134284375214662245037202945590183
_N = 11884142558095727641000594156833818117849240126500615037738361957005811068956622520280143210434649198031005585252791693777710458190732464123269660559382653636999601459113099276826723072914352276709761755328542359490331355061792823458149611674845846523699218971126655186522340818792078719216860046464292413878045842425132308544311887062610272360069819975798905665533964761527225558339025724872067751916657135473510775709503714808686565298632040214249698116863336246844759838665285888816202570667521796553678688293761589082062045634768520102235077364345013564344229095323239077977717497503322831684471959195555281580807
_e = 65537
_c = 11776079752956619284016871274992903352398310565005810097721997339193718454945819135683541554652454321040530044545154341786048659896370226535387839157317585368391189570502841702311449000698372030666509296004039398083488490698999338894328619127149024309470011330855840757405205104944658961386764569043610715311746676861275270073394069269043429092551681704290340091149637137627751767730812255069347108706434972786681985484368054390699974613090342753508097177008167140924577095976699437810398922852319420301082587264411993737330188227703869101718515748828944300463051133118636928879090217708121368293440440444106196607645

for i in range(0x1337*0+6428,0x1337 + 0x1337):
	print(i)
	NBITS = 1024
	p0, p = getStrongestPrime(_p0,i)
	if _N % p != 0:
		continue
	q = _N //p
	N = p * q
	d = pow(e,-1,(p-1)*(q-1))
	print(long_to_bytes(pow(_c,d,N)))
	break

# vsctf{Strongest_can_be_the_weakest:(}